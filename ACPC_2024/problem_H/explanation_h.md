هذا البرنامج يحل مسألة "Nile's Flowing Currents" من مسابقة ACPC 2024. تتلخص المسألة في إيجاد القيمة المتوقعة لتكلفة سلسلة مكونة من $n$ سلسلة نصية. تُعرف التكلفة بأنها مجموع أطول تداخل (تطابق بين لاحقة وسابقة) بين كل زوجين متجاورين من السلاسل في ترتيب عشوائي.

---

### **الفكرة الرئيسية (الخوارزمية)**

تعتمد الخوارزمية بشكل أساسي على **خاصية الخطية في التوقع (Linearity of Expectation)**. بدلاً من حساب التوقع لكل ترتيب عشوائي على حدة (وهو أمر غير ممكن بسبب العدد الهائل من الترتيبات)، يمكننا تبسيط المسألة إلى التالي:

1.  **تحليل التوقع:** التكلفة المتوقعة لسلسلة هي مجموع التوقعات لكل زوج من السلاسل المتجاورة. بما أن أي زوجين من السلاسل (`s_i`, `s_j`) لهما نفس احتمال التجاور في أي موضع، يمكننا تعميم العلاقة كالتالي:

    $E[\text{Cost}] = \frac{1}{n} \times \sum_{k \neq l} F(s_k, s_l)$

    حيث $F(s_k, s_l)$ هو طول أطول لاحقة لـ `s_k` هي أيضاً سابقة لـ `s_l`.

2.  **بناء آلة الأوتوماتا النهائية المعممة (Generalized Suffix Automaton - GSA):**
    * الطريقة المباشرة لحساب $\sum_{k,l} F(s_k, s_l)$ هي المرور على جميع الأزواج الممكنة، وهي بطيئة جداً ($O(N^2 \cdot \text{max\_len})$).
    * للتعامل مع هذا التحدي، تُستخدم بنية بيانات متقدمة تُسمى "آلة الأوتوماتا النهائية المعممة" (GSA).
    * يتم بناء GSA لجميع السلاسل المُعطاة في وقت واحد، مع إضافة حرف فاصل فريد بين كل سلسلة وأخرى لمنع التداخلات غير المرغوبة.
    * كل حالة (state) في GSA تُمثل مجموعة من السلاسل الجزئية (substrings) المشتركة.
    * من خلال GSA، يمكننا حساب:
        * `cnt_pref[u]`: عدد السلاسل الأصلية التي تحتوي على السلاسل الجزئية الممثلة بالحالة `u` كسابقة لها.
        * `cnt_suf[u]`: عدد السلاسل الأصلية التي تحتوي على السلاسل الجزئية الممثلة بالحالة `u` كلاحقة لها.

3.  **حساب المجموع الكلي:**
    * يمكن حساب مجموع الأطوال لجميع التداخلات الممكنة (بما في ذلك التداخلات مع السلسلة نفسها) باستخدام GSA:

    $\sum_{k,l} F(s_k, s_l) = \sum_{u} (\text{len}(u) - \text{len}(\text{link}(u))) \times \text{cnt\_suf}[u] \times \text{cnt\_pref}[u]$

    * `len(u)`: طول أطول سلسلة جزئية للحالة `u`.
    * `len(link(u))`: طول أطول سلسلة جزئية في الحالة المرتبطة باللاحقة `link(u)`.
    * `len(u) - len(link(u))`: يُمثل عدد السلاسل الجزئية الفريدة التي تمثلها الحالة `u`.

4.  **تصحيح المجموع:**
    * المعادلة السابقة تحسب المجموع لكل الأزواج `(k, l)`، بما في ذلك الحالات التي تكون فيها السلسلتان متطابقتين `(k=l)`.
    * يجب طرح قيمة $\sum_{k=1}^n F(s_k, s_k)$ من المجموع الكلي.
    * `F(s_k, s_k)` هو طول أطول لاحقة حقيقية لـ `s_k` تكون سابقة لها أيضاً. هذه القيمة تُعادل `len(link(end_state))` لحالة نهاية السلسلة `s_k` في GSA.

5.  **حساب النتيجة النهائية:**
    * بعد حساب المجموع للأزواج المختلفة، يتم قسمته على `n` (مع استخدام المعكوس الضربي الموديلو) للحصول على القيمة المتوقعة النهائية.

---

### **تطبيق الخوارزمية في الكود**

#### **1. هيكل `Node`**
* يُمثل حالة في آلة الأوتوماتا. يحتوي على:
    * `len`: طول أطول سلسلة جزئية تنتهي عند هذه الحالة.
    * `link`: مؤشر إلى حالة اللاحقة (suffix link).
    * `next`: خريطة (map) للحروف ومؤشراتها إلى الحالات التالية.

#### **2. دوال بناء GSA**
* `gsa_init()`: تُهيئ الأوتوماتا، وتنشئ الحالة الجذرية (root state) التي تُمثل السلسلة الفارغة.
* `gsa_extend(char c)`: تُضيف حرفًا جديدًا إلى الأوتوماتا. هذه هي الوظيفة الأساسية التي تبني الهيكل، حيث تُنشئ حالات جديدة وتُحدّث روابط اللاحقات (suffix links) بشكل صحيح.

#### **3. دالة `main()`**
* **الإعداد:** تُسرّع عمليات الإدخال والإخراج.
* **قراءة البيانات:** تقرأ عدد السلاسل `n` والسلاسل نفسها.
* **بناء GSA:**
    * تُنشئ متجهًا لتخزين حالات النهاية لكل سلسلة (`end_states`).
    * تمر على جميع السلاسل، وتضيف كل حرف باستخدام `gsa_extend()`.
    * تُسجل حالة النهاية لكل سلسلة في `end_states`.
    * تُضيف حرفًا فاصلًا فريدًا بين كل سلسلة وأخرى.
* **حساب التكرارات:**
    * **`cnt_pref`:** يتم حساب عدد تكرارات السوابق بالمرور على كل سلسلة من جديد في GSA وزيادة عداد `cnt_pref` للحالة التي يتم الوصول إليها.
    * **`cnt_suf`:** يتم تهيئة `cnt_suf` بناءً على حالات النهاية لكل سلسلة، ثم يتم نشر (propagate) هذه الأعداد إلى الأعلى في شجرة روابط اللاحقات (suffix link tree). يتم تحقيق ذلك بفرز الحالات ترتيبًا تنازليًا حسب الطول، ثم تحديث `cnt_suf[state[u].link] += cnt_suf[u]`.
* **حساب المجموع الكلي:**
    * تُنشئ حلقة تكرارية على جميع حالات GSA.
    * لكل حالة `u`، تُحسب مساهمتها في المجموع بناءً على الصيغة: `(len(u) - len(link(u))) * cnt_pref[u] * cnt_suf[u]`.
* **حساب المجموع لأزواج متطابقة:**
    * تُنشئ حلقة تكرارية على `end_states`.
    * لكل حالة نهاية `end_state_idx` لسلسلة، تُضيف طول رابط اللاحقة الخاص بها `state[state[end_state_idx].link].len` إلى `diag_sum`.
* **النتيجة النهائية:**
    * تُطرح `diag_sum` من `total_sum` للحصول على `final_sum`.
    * تُحسب القيمة المتوقعة بقسمة `final_sum` على `n` (باستخدام المعكوس الضربي).
    * تُطبع النتيجة النهائية.

**ملاحظة:** جميع العمليات الحسابية تتم باستخدام **النمط (modulo)** $10^9+7$ لتجنب تجاوز سعة المتغيرات.