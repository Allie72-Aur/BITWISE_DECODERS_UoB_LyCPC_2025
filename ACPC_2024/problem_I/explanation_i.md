هذا البرنامج يحل مسألة "Pharaoh's Sliding Chamber" من مسابقة ACPC 2024. تُمثل المسألة لغزًا انزلاقيًا حيث الهدف هو نقل بلاطة مُعينة إلى موقع محدد في شبكة، باستخدام ثقب فارغ وبلاطات متحركة، مع وجود بلاطات ثابتة لا يمكن تحريكها.

---

### **الفكرة الرئيسية (الخوارزمية)**

تُصنّف هذه المسألة على أنها مشكلة **أقصر مسار (shortest path problem)** في "مخطط فضاء الحالات (state space graph)". يمكن حلها بفعالية باستخدام خوارزمية **البحث في العرض أولاً (Breadth-First Search - BFS)**.

**فضاء الحالات:**
* حالة اللغز في أي لحظة تُعرّف بموقعين رئيسيين: موقع البلاطة المستهدفة وموقع الثقب.
* يمكن تمثيل كل حالة بزوج من الإحداثيات `(x_target, y_target, x_hole, y_hole)`.

**خوارزمية BFS:**
1.  **التهيئة:**
    * يتم إنشاء **قائمة انتظار (queue)** وتُضاف إليها الحالة الابتدائية: `(x_target_initial, y_target_initial, x_hole_initial, y_hole_initial, 0)`, حيث `0` هو عدد الحركات.
    * يتم إنشاء مجموعة (`std::unordered_set`) لتتبع الحالات التي تمت زيارتها (`visited`) لتجنب الحلقات اللانهائية والعمليات المكررة. يجب استخدام دالة هاش مُخصصة (`StateHash`) لتتمكن `unordered_set` من تخزين هذا النوع من البيانات.
    * يتم إضافة الحالة الابتدائية إلى مجموعة `visited`.

2.  **التنفيذ:**
    * تستمر الخوارزمية في العمل طالما أن قائمة الانتظار غير فارغة.
    * في كل خطوة، تُسحب الحالة الأولى من قائمة الانتظار.
    * **التحقق من الهدف:** إذا كانت إحداثيات البلاطة المستهدفة في الحالة الحالية هي نفسها إحداثيات الهدف `(N, M)`، يتم إيقاف البحث وطباعة عدد الحركات المرتبط بهذه الحالة. هذه هي الإجابة المثلى لأن BFS يضمن إيجاد أقصر مسار.
    * **استكشاف الحركات الممكنة:**
        * يتم استكشاف جميع المواقع المجاورة للثقب في جميع الاتجاهات الثمانية (أفقي، عمودي، وقطري).
        * لكل موقع مجاور:
            * إذا كانت البلاطة في هذا الموقع داخل حدود الشبكة وليست بلاطة ثابتة (`immovable_tile`)، فهذا يُمثل حركة ممكنة.
            * تُنشأ حالة جديدة حيث يتبادل موقع البلاطة وموقع الثقب. إذا كانت البلاطة المُتحركة هي البلاطة المستهدفة، يتم تحديث إحداثياتها في الحالة الجديدة.
    * **التحديث:**
        * إذا لم يتم زيارة الحالة الجديدة من قبل (باستخدام مجموعة `visited`)، يتم إضافتها إلى مجموعة `visited` وقائمة الانتظار مع زيادة عدد الحركات بواحد.

3.  **الاستنتاج:**
    * إذا أصبحت قائمة الانتظار فارغة قبل الوصول إلى الهدف، فهذا يعني أن الهدف لا يمكن الوصول إليه من الحالة الابتدائية، ويتم طباعة `-1`.

---

### **تطبيق الخوارزمية في الكود**

#### **1. دالة الهاش (`StateHash`)**
* تُعرّف دالة هاش مُخصصة للحالات (`tuple<int, int, int, int>`).
* هذه الدالة ضرورية لتمكين `std::unordered_set` من تخزين هذه البيانات المعقدة بكفاءة.
* تقوم بتحويل إحداثيات الحالة الأربعة إلى قيمة هاش واحدة عن طريق دمجها بشكل فريد.

#### **2. دالة `main()`**
* **الإعداد:** تُسرّع عمليات الإدخال والإخراج (`std::ios_base::sync_with_stdio(false);`).
* **قراءة البيانات:**
    * تُقرأ أبعاد الشبكة `N` و`M`.
    * تُقرأ إحداثيات البلاطة المستهدفة والثقب.
    * تُقرأ عدد البلاطات الثابتة `Z` وإحداثياتها، وتُخزن في مصفوفة ثنائية (`std::vector<std::vector<bool>>`) لسهولة التحقق منها لاحقًا.
* **البحث (`BFS`):**
    * تُنشأ قائمة انتظار (`std::queue`) ومتغير `visited` (`std::unordered_set`).
    * تُضاف الحالة الأولية إلى قائمة الانتظار ومجموعة `visited`.
    * تُعرّف المصفوفات `dx` و`dy` التي تحتوي على إزاحات الاتجاهات الثمانية.
    * تُنفّذ حلقة `while (!q.empty())` الرئيسية.
    * داخل الحلقة:
        * تُسحب الحالة الحالية من قائمة الانتظار.
        * يتم التحقق مما إذا كانت البلاطة المستهدفة في موقعها النهائي. إذا كان الأمر كذلك، تُطبع النتيجة ويُنهى البرنامج.
        * تُنفّذ حلقة `for` لاستكشاف جميع الاتجاهات الثمانية حول الثقب.
        * يتم التحقق من أن البلاطة المراد تحريكها ضمن الحدود وغير ثابتة.
        * تُحسب إحداثيات الحالة الجديدة. إذا كانت البلاطة التي ستُحرك هي البلاطة المستهدفة، يتم تحديث إحداثياتها الجديدة إلى إحداثيات الثقب القديمة.
        * يتم التحقق من عدم زيارة الحالة الجديدة، وإذا كانت كذلك، تُضاف إلى قائمة الانتظار ومجموعة `visited`.
* **التعامل مع الحالات المستحيلة:**
    * إذا انتهت حلقة `while` (أي أصبحت قائمة الانتظار فارغة)، فهذا يعني أن الهدف غير قابل للوصول، ويُطبع `-1`.
